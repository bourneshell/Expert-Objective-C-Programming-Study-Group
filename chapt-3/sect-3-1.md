# 3.1 Grand Central Dispatch 概要

## 3.1.1 Grand Central Dispatch とは何か？

[Appleの技術文書](http://developer.apple.com/jp/devcenter/ios/library/documentation/ConcurrencyProgrammingGuide.pdf)によると、Grand Central Dispatch(GCD)とは

* __タスクを非同期に実行__する技術のひとつ
* スレッド管理用のコードを__システムレベルで実装__
 - 従来はアプリケーション中に記述
* 開発者がすることとGCDがしてくれること

|開発者がすること                  |GCDがしてくれること                     |
|:---------------------------------|:---------------------------------------|
|実行したいタスクの定義            |必要なスレッドを生成                    |
|タスクを適切なDispatch Queueに追加|スレッドでのタスク実行をスケジューリング|

* 従来のスレッドよりも__効率が向上__

### GCDがある時

長い処理を別スレッドで実行後にメインスレッドで結果処理を行う場合、GCDを使うとこんな感じ。

```objectivec
dispatch_async(queue, ^{

    // 長い処理

    // 長い処理が終わったらメインスレッドで処理
    dispatch_async(dispatch_get_main_queue(), ^{
        // UI操作などメインスレッドでのみ実行可能な処理
    });
});
```

以下の1行だけでバックグラウンドに処理を実行させることができる。

```objectivec
dispatch_async(queue, ^{
```

そして、同様に以下の1行だけでメインスレッドに処理を実行させることができる。

```objectivec
dispatch_async(dispatch_get_main_queue(), ^{
```

### GCDが無い時

GCD導入以前から、CocoaフレームワークはNSObjectクラスのperformSelectorInBackgroundインスタンスメソッドやperformSelectorOnMainThreadインスタンスメソッドを使ったマルチスレッドプログラミングのための仕組みを提供している。

先ほどと同様の処理をGCDを使わずに行うとこんな感じ。

```objectivec
- (void)launchThreadByNSObject_performSelectorInBackground_withObject
{
    [self performSelectorInBackground:@selector(doWork) withObject:nil];
}

// バックグラウンドスレッドで動作するメソッド
- (void)doWork
{
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];

    // 長い処理

    // 長い処理が終わったらメインスレッドで処理
    [self performSelectorOnMainThread:@selector(doneWork) withObject:nil waitUntilDone:NO];

    [pool drain];
}

// メインスレッドで動作するメソッド
- (void)doneWork
{
    // UI操作などメインスレッドでのみ実行可能な処理
}
```

NSThreadクラスを使うよりは簡単だが、それでも断然GCDの方が簡潔に記述できる。

## 3.1.2 マルチスレッドプログラミング

### MacやiPhone上でのプログラム実行

ソースコードが実際に実行されるまでの流れは以下の通り。

1. 開発者がObjective-Cで__ソースコード__を書く
2. コンパイラがソースコードを__CPU命令列(バイトコード)__に変換
3. バイトコードを__アプリケーション__としてMacやiPhone上にインストールする
4. アプリケーションが実行されると__バイトコードはメモリ上に配置__される
5. CPUは__バイトコードを1つずつ実行__していく

上記の5にある、__「1つのCPUによる一連のバイトコードの実行」__が1つの__「スレッド」__となる。

これを複数同時に実行することを__マルチスレッド__と呼ぶ。

### マルチスレッドの実現方法

基本的には、__1つのCPUコアが一度に実行できるCPU命令は1つまで。__マルチスレッドでの実行を行う方法は以下の2つ。

##### 1. コンテキストスイッチを使う

###### コンテキストスイッチとは？

  - OS X、iOSの中核であるXNUカーネルは、一滴時間が経過したり、システムコール呼び出しなどのOS上のイベントが発生した場合、実行するスレッドを切り替える
  - 切り替えるために、実行中のスレッドのCPUレジスタ情報をメモリ領域に退避させ、次に実行するスレッドのレジスタ情報をメモリから読み込み後にそのスレッドのバイトコードを実行する。 
  - このスレッド切り替えを__コンテキストスイッチ__と呼ぶ

あるスレッドから別のスレッドへのコンテキストスイッチを何度も繰り返すことで、1つのCPUコアで複数のスレッド並列に実行されているように見せる。

##### 2. マルチコアCPUでの実行

複数のCPUコアが存在するCPUの場合は、各コアがそれぞれスレッドを並列実行させることが可能。ちなみにiPhoneはiPhone 4SからマルチコアCPUを搭載

### マルチスレッドプログラミングの問題点

マルチスレッドプログラミングでよく起きる問題点は以下の３つ。これらの問題を考慮した上でプログラミングを行うと、プログラムが複雑になってしまう。

* データ競合

  複数のスレッドが同じデータを更新する事によるデータ不整合の発生。

* デッドロック

  複数のリソースがお互いに相手のスレッドの処理待ちになることで以降の処理が進まない。

* 多量のスレッド生成による大量のメモリ消費

### マルチスレッドプログラミングのメリット

上記の問題点がありながらも、多くのアプリケーションでマルチスレッドプログラミングが利用されている理由として、__アプリケーションの応答性能を保つ__ことが挙げられる。

* アプリケーションでは、UIの描画やタッチパネルのイベント処理はアプリケーション起動時に最初に実行されるスレッドである__メインスレッド__で行われる。
* メインスレッドで以下のような時間のかかる処理を行うと、メインスレッドの実行が妨げられる
  - AR用に画像認識
  - データベースアクセス
* OS X、iOSアプリケーションでは、メインスレッドで動作している__RunLoop__と呼ばれるメインループの実行が妨げられるため、ユーザインターフェースが更新されず画面が長時間止まってしまう
* 長時間かかる処理を別のスレッドで実行することで、メインスレッドに負荷の高い処理は行わせない

